--------------------
100_doors
--------------------

=={{header|FunL}}==
=== Unoptimized ===
<lang funl>for i <- 1..100
  r = foldl1( (a, b) -> a xor b, [(a|i) | a <- 1..100] )
  println( i + ' ' + (if r then 'open' else 'closed') )</lang>

=== Optimized ===
<lang funl>import math.sqrt

for i <- 1..100
  println( i + ' ' + (if sqrt(i) is Integer then 'open' else 'closed') )</lang>

--------------------
99_Bottles_of_Beer
--------------------

=={{header|FunL}}==
<lang funl>val
  numbers = {1:'one', 2:'two', 3:'three', 4:'four', 5:'five', 6:'six', 7:'seven',
    8:'eight', 9:'nine', 10:'ten', 11:'eleven', 12:'twelve'}
  alt = {3:'thir', 5:'fif'}

def
  suffix( a, b ) = (if a.endsWith( 't' ) then a.substring( 0, a.length()-1 ) else a) + b

  number( n@(13 | 15) ) = suffix( alt(n%10), 'teen' )
  number( 20 ) = 'twenty'
  number( n@(30 | 50) ) = suffix( alt(n\10), 'ty' )
  number( n )
    | n <= 12 = numbers(n)
    | n <= 19 = suffix( numbers(n%10), 'teen' )
    | 10|n = suffix( numbers(n\10), 'ty' )
    | otherwise = number( n\10*10 ) + '-' + number( n%10 )

  cap( s ) = s.substring( 0, 1 ).toUpperCase() + s.substring( 1, s.length() )

  bottles( 0 ) = 'no more bottles'
  bottles( 1 ) = 'one bottle'
  bottles( n ) = number( n ) + ' bottles'

  verse( 0 )   = ('No more bottles of beer on the wall, no more bottles of beer.\n'
                  + 'Go to the store and buy some more, ninety-nine bottles of beer on the wall.')
  verse( n )   = (cap( bottles(n) ) + ' of beer on the wall, ' + bottles( n ) + ' of beer.\n'
                  + 'Take one down and pass it around, ' + bottles( n-1 )
                  + ' of beer on the wall.\n')

for i <- 99..0 by -1 do println( verse(i) )</lang>

--------------------
A%2BB
--------------------

=={{header|FunL}}==
<lang funl>println( sum(map(int, readLine().split(' +'))) )</lang>

--------------------
Ackermann_function
--------------------

=={{header|FunL}}==
<lang funl>def
  ackermann( 0, n ) = n + 1
  ackermann( m, 0 ) = ackermann( m - 1, 1 )
  ackermann( m, n ) = ackermann( m - 1, ackermann(m, n - 1) )

for m <- 0..3, n <- 0..4
  println( m, n, ackermann(m, n) )</lang>

--------------------
Bernoulli_numbers
--------------------

=={{header|FunL}}==
FunL has pre-defined function <code>B</code> in module <code>integers</code>, which is defined as:
<lang funl>import integers.choose

def B( n ) = sum( 1/(k + 1)*sum((if 2|r then 1 else -1)*choose(k, r)*(r^n) | r <- 0..k) | k <- 0..n )

for i <- 0..60 if i == 1 or 2|i
  printf( "B(%2d) = %s\n", i, B(i) )</lang>

{{out}}
<pre>
B( 0) = 1
B( 1) = -1/2
B( 2) = 1/6
B( 4) = -1/30
B( 6) = 1/42
B( 8) = -1/30
B(10) = 5/66
B(12) = -691/2730
B(14) = 7/6
B(16) = -3617/510
B(18) = 43867/798
B(20) = -174611/330
B(22) = 854513/138
B(24) = -236364091/2730
B(26) = 8553103/6
B(28) = -23749461029/870
B(30) = 8615841276005/14322
B(32) = -7709321041217/510
B(34) = 2577687858367/6
B(36) = -26315271553053477373/1919190
B(38) = 2929993913841559/6
B(40) = -261082718496449122051/13530
B(42) = 1520097643918070802691/1806
B(44) = -27833269579301024235023/690
B(46) = 596451111593912163277961/282
B(48) = -5609403368997817686249127547/46410
B(50) = 495057205241079648212477525/66
B(52) = -801165718135489957347924991853/1590
B(54) = 29149963634884862421418123812691/798
B(56) = -2479392929313226753685415739663229/870
B(58) = 84483613348880041862046775994036021/354
B(60) = -1215233140483755572040304994079820246041491/56786730
</pre>

--------------------
Command-line_arguments
--------------------

=={{header|FunL}}==
<lang funl>println( args )</lang>

--------------------
Dot_product
--------------------

=={{header|FunL}}==
<lang funl>import lists.zipWith

def dot( a, b )
  | a.length() == b.length() = sum( zipWith((x, y) -> x*y, a, b) )
  | otherwise = error( "Vector sizes must match" )

println( dot([1, 3, -5], [4, -2, -1]) )</lang>
{{out}}<pre>3</pre>

--------------------
Draw_a_clock
--------------------

=={{header|FunL}}==
<lang funl>import concurrent.{scheduleAtFixedRate, scheduler}

val ROW = 10
val COL = 20
val digits = array( [
  "   __",
  " /  /",
  "/__/ ",
  "     ",
  "    /",
  "   / ",
  "   __",
  "  __/",
  "/__  ",
  "   __",
  "  __/",
  " __/ ",
  "     ",
  " /__/",
  "   / ",
  "   __",
  " /__ ",
  " __/ ",
  "   __",
  " /__ ",
  "/__/ ",
  "   __",
  "    /",
  "   / ",
  "   __",
  " /__/",
  "/__/ ",
  "   __",
  " /__/",
  " __/ "
  ] )
val colon = array( [
  "  ",
  " .",
  ". "
  ] )

def displayTime =
  def pad( n ) = if n < 10 then '0' + n else n

  t = $time
  s = (t + $timeZoneOffset)\1000%86400
  time = pad( s\3600 ) + ':' + pad( s%3600\60 ) + ':' + pad( s%60 )

  for row <- 0:3
    print( if $os.startsWith('Windows') then '\n' else '\u001B[' + (ROW + row) + ';' + COL + 'H' )

    for ch <- time
      print( if ch == ':' then colon(row) else digits(int(ch)*3 + row) )

  println()
  t

if not $os.startsWith( 'Windows' )
  print( '\u001B[2J\u001B[?25l' )

scheduleAtFixedRate( displayTime, 1000 - displayTime()%1000, 1000 )
readLine()
scheduler().shutdown()

if not $os.startsWith( 'Windows' )
  print( '\u001B[?25h' )</lang>

{{out}}
<pre>
  __   __     __   __          __
  __/ /  / .  __/    / . /__/    /
/__  /__/ . /__     / .    /    /
</pre>

--------------------
Evaluate_binomial_coefficients
--------------------

=={{header|FunL}}==
FunL has pre-defined function <code>choose</code> in module <code>integers</code>, which is defined as:
<lang funl>def
  choose( n, k ) | k < 0 or k > n = 0
  choose( n, 0 ) = 1
  choose( n, n ) = 1
  choose( n, k ) = product( [(n - i)/(i + 1) | i <- 0:min( k, n - k )] )

println( choose(5, 3) )
println( choose(60, 30) )</lang>
{{out}}
<pre>
10
118264581564861424
</pre>

Here it is defined using the recommended formula for this task.
<lang funl>import integers.factorial

def
  binomial( n, k ) | k < 0 or k > n = 0
  binomial( n, k ) = factorial( n )/factorial( n - k )/factorial( k )</lang>

--------------------
Execute_a_system_command
--------------------

=={{header|FunL}}==
<lang funl>import sys.execute

execute( if $os.startsWith('Windows') then 'dir' else 'ls' )</lang>

--------------------
Factorial
--------------------

=={{header|FunL}}==
=== Procedural ===
<lang funl>def factorial( n ) =
  if n < 0
    error( "factorial: n should be non-negative" )
  else
    res = 1

    for i <- 1..n
      res *= i

    res</lang>

=== Recursive ===
<lang funl>def
  factorial( (0|1) ) = 1
  factorial( n )
    | n > 0 = n*factorial( n - 1 )
    | otherwise = error( "factorial: n should be non-negative" )</lang>

=== Tail-recursive ===
<lang funl>def factorial( n )
  | n >= 0 =
    def
      fact( acc, 0 ) = acc
      fact( acc, n ) = fact( acc*n, n - 1 )

    fact( 1, n )
  | otherwise = error( "factorial: n should be non-negative" )</lang>

=== Using a library function (which uses folding) ===
<lang funl>def factorial( n )
  | n >= 0 = product( 1..n )
  | otherwise = error( "factorial: n should be non-negative" )</lang>

--------------------
Fibonacci_n-step_number_sequences
--------------------

=={{header|FunL}}==
<lang funl>import util.TextTable
native scala.collection.mutable.Queue

def fibLike( init ) =
  q = Queue()
  q.enqueue( init )

  def fib =
    q.enqueue( sum(q) )
    q.dequeue() # fib()

  0 # fib()

def fibN( n ) = fibLike( [1] + [2^(i - 2) | i <- 2..n] )

val lucas = fibLike( [2, 1] )

t = TextTable()
t.header( 'k', 'Fibonacci', 'Tribonacci', 'Tetranacci', 'Lucas' )
t.line()

for i <- 1..5
  t.rightAlignment( i )

seqs = (fibN(2), fibN(3), fibN(4), lucas)

for i <- 1..10
  t.row( [i] + [seqs(j)(i) | j <- 0:4] )

print( t )</lang>

{{out}}

<pre>
+----+-----------+------------+------------+-------+
| k  | Fibonacci | Tribonacci | Tetranacci | Lucas |
+----+-----------+------------+------------+-------+
|  1 |         1 |          1 |          1 |     2 |
|  2 |         1 |          1 |          1 |     1 |
|  3 |         2 |          2 |          2 |     3 |
|  4 |         3 |          4 |          4 |     4 |
|  5 |         5 |          7 |          8 |     7 |
|  6 |         8 |         13 |         15 |    11 |
|  7 |        13 |         24 |         29 |    18 |
|  8 |        21 |         44 |         56 |    29 |
|  9 |        34 |         81 |        108 |    47 |
| 10 |        55 |        149 |        208 |    76 |
+----+-----------+------------+------------+-------+
</pre>

--------------------
Fibonacci_sequence
--------------------

=={{header|FunL}}==
=== Recursive ===
<lang funl>def
  fib( 0 ) = 0
  fib( 1 ) = 1
  fib( n ) = fib( n - 1 ) + fib( n - 2 )</lang>

=== Tail Recursive ===
<lang funl>def fib( n ) =
  def
    _fib( 0, prev, _ )    = prev
    _fib( 1, _,    next ) = next
    _fib( n, prev, next ) = _fib( n - 1, next, next + prev )

  _fib( n, 0, 1 )</lang>

=== Lazy List ===
<lang funl>val fib =
  def _fib( a, b ) = a # _fib( b, a + b )

  _fib( 0, 1 )

println( fib(10000) )</lang>

{{out}}

<pre>
3364476487643178326662161200510754331030214846068006390656476997468008144216666236815559551363373402558206533268083615937373479048386526826304089246305643188735454436955982749160660209988418393386465273130008883026923567361313511757929743785441375213052050434770160226475831890652789085515436615958298727968298751063120057542878345321551510387081829896979161312785626503319548714021428753269818796204693609787990035096230229102636813149319527563022783762844154036058440257211433496118002309120828704608892396232883546150577658327125254609359112820392528539343462090424524892940390170623388899108584106518317336043747073790855263176432573399371287193758774689747992630583706574283016163740896917842637862421283525811282051637029808933209990570792006436742620238978311147005407499845925036063356093388383192338678305613643535189213327973290813373264265263398976392272340788292817795358057099369104917547080893184105614632233821746563732124822638309210329770164805472624384237486241145309381220656491403275108664339451751216152
6545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562
430701794976171121233066073310059947366875
</pre>

=== Iterative ===
<lang funl>def fib( n ) =
  a, b = 0, 1

  for i <- 1..n
    a, b = b, a+b

  a</lang>

=== Binet's Formula ===
<lang funl>import math.sqrt

def fib( n ) =
  phi = (1 + sqrt( 5 ))/2
  int( (phi^n - (-phi)^-n)/sqrt(5) + .5 )</lang>

=== Matrix Exponentiation ===
<lang funl>def mul( a, b ) =
  res = array( a.length(), b(0).length() )

  for i <- 0:a.length(), j <- 0:b(0).length()
    res( i, j ) = sum( a(i, k)*b(k, j) | k <- 0:b.length() )

  vector( res )

def
  pow( _, 0 ) = ((1, 0), (0, 1))
  pow( x, 1 ) = x
  pow( x, n )
    | 2|n = pow( mul(x, x), n\2 )
    | otherwise = mul(x, pow( mul(x, x), (n - 1)\2 ) )

def fib( n ) = pow( ((0, 1), (1, 1)), n )(0, 1)

for i <- 0..10
  println( fib(i) )</lang>

{{out}}

<pre>
0
1
1
2
3
5
8
13
21
34
55
</pre>

--------------------
Generator/Exponential
--------------------

=={{header|FunL}}==
{{trans|Scala}} (for the filter)
<lang funl>import util.from

def powers( m ) = map( (^ m), from(0) )

def
  filtered( s@sh:_, ch:ct ) | sh > ch = filtered( s, ct )
  filtered( sh:st, c@ch:_ ) | sh < ch = sh # filtered( st, c )
  filtered( _:st, c ) = filtered( st, c )

println( filtered(powers(2), powers(3)).drop(20).take(10) )</lang>
{{out}}
<pre>
[529, 576, 625, 676, 784, 841, 900, 961, 1024, 1089]
</pre>

--------------------
Greatest_common_divisor
--------------------

=={{header|FunL}}==
FunL has pre-defined function <code>gcd</code> in module <code>integers</code> defined as:

<lang funl>def
  gcd( 0, 0 ) = error( 'integers.gcd: gcd( 0, 0 ) is undefined' )
  gcd( a, b ) =
    def
      _gcd( a, 0 ) = a
      _gcd( a, b ) = _gcd( b, a%b )

    _gcd( abs(a), abs(b) )</lang>

--------------------
Greatest_element_of_a_list
--------------------

=={{header|FunL}}==
Using the pre-defined function <code>max</code>:
<lang funl>println( max([1,2,3,-1,0]) )</lang>
{{out}}
<pre>
3
</pre>

It can be implemented as:
<lang funl>def
  maximum( xs ) =
    def
      max( a, b )             = if a <= b then b else a

      foldl( f, z, [] )       = z
      foldl( f, z, x:xs )     = foldl( f, f(z, x), xs )

      foldl1( f, x:xs )       = foldl( f, x, xs )
      foldl1( _, [] )         = error( "foldl1: empty list" )

    foldl1( max, xs )</lang>

--------------------
Hailstone_sequence
--------------------

=={{header|FunL}}==
<lang funl>def
  hailstone( 1 ) = [1]
  hailstone( n ) = n # hailstone( if 2|n then n/2 else n*3 + 1 )

if _name_ == '-main-'
  h27 = hailstone( 27 )
  assert( h27.length() == 112 and h27.startsWith([27, 82, 41, 124]) and h27.endsWith([8, 4, 2, 1]) )

  val (n, len) = maxBy( snd, (i, hailstone( i ).length()) | i <- 1:100000 )

  println( n, len )</lang>

{{out}}

<pre>
77031, 351
</pre>

--------------------
Hello_world/Graphical
--------------------

=={{header|FunL}}==
<lang funl>native javax.swing.{SwingUtilities, JPanel, JLabel, JFrame}
native java.awt.Font

def createAndShowGUI( msg ) =
  f = JFrame()
  f.setTitle( msg )
  f.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE )
  p = JPanel()
  l = JLabel( msg )
  l.setFont( Font.decode(Font.SERIF + ' 150') )
  p.add( l )
  f.add( p )
  f.pack()
  f.setResizable( false )
  f.setVisible( true )

SwingUtilities.invokeLater( createAndShowGUI.runnable('Goodbye, World!') )</lang>

--------------------
Hello_world/Web_server
--------------------

=={{header|FunL}}==
<lang funl>native java.io.PrintWriter
native java.net.ServerSocket

val port = 8080
val listener = ServerSocket( port )

printf( 'Listening at port %1$d\n', port )

forever
  socket = listener.accept()
  PrintWriter( socket.getOutputStream(), true ).println( 'hello world' )
  socket.shutdownOutput()
  socket.close()</lang>

--------------------
Integer_sequence
--------------------

=={{header|FunL}}==
The following uses built-in method <code>from</code> in Scala's <code>Stream</code> (class companion) object, but has a limit (2147483647).
<lang funl>native scala.collection.immutable.Stream

for i <- Stream.from( 1 ) do println( i )</lang>

This version has no limit because it uses FunL's arbitrary size integers.

<lang funl>def from( n ) = n # from( n + 1 )

for i <- from( 1 )
  println( i )</lang>

--------------------
Matrix_arithmetic
--------------------

=={{header|FunL}}==
From the task description:
<lang funl>def sgn( p ) = product( (if s(0) < s(1) xor i(0) < i(1) then -1 else 1) | (s, i) <- p.combinations(2).zip( (0:p.length()).combinations(2) ) )

def perm( m ) = sum( product(m(i, sigma(i)) | i <- 0:m.length()) | sigma <- (0:m.length()).permutations() )

def det( m ) = sum( sgn(sigma)*product(m(i, sigma(i)) | i <- 0:m.length()) | sigma <- (0:m.length()).permutations() )</lang>

Laplace expansion (recursive):
<lang funl>def perm( m )
  | m.length() == 1 and m(0).length() == 1 = m(0, 0)
  | otherwise = sum( m(i, 0)*perm(m(0:i, 1:m.length()) + m(i+1:m.length(), 1:m.length())) | i <- 0:m.length() )

def det( m )
  | m.length() == 1 and m(0).length() == 1 = m(0, 0)
  | otherwise = sum( (-1)^(i - 1)*m(i, 0)*det(m(0:i, 1:m.length()) + m(i+1:m.length(), 1:m.length())) | i <- 0:m.length() )</lang>

Test using the first set of definitions (from task description):
<lang funl>matrices = [
  ( (1, 2),
    (3, 4)),
  ( (-2, 2, -3),
    (-1, 1,  3),
    ( 2, 0, -1)),
  ( ( 1,  2,  3,  4),
    ( 4,  5,  6,  7),
    ( 7,  8,  9, 10),
    (10, 11, 12, 13)),
  ( ( 0,  1,  2,  3,  4),
    ( 5,  6,  7,  8,  9),
    (10, 11, 12, 13, 14),
    (15, 16, 17, 18, 19),
    (20, 21, 22, 23, 24)) ]

for m <- matrices
  println( m, 'perm: ' + perm(m), 'det: ' + det(m) )</lang>

{{out}}

<pre>
((1, 2), (3, 4)), perm: 10, det: -2
((-2, 2, -3), (-1, 1, 3), (2, 0, -1)), perm: 10, det: 18
((1, 2, 3, 4), (4, 5, 6, 7), (7, 8, 9, 10), (10, 11, 12, 13)), perm: 29556, det: 0
((0, 1, 2, 3, 4), (5, 6, 7, 8, 9), (10, 11, 12, 13, 14), (15, 16, 17, 18, 19), (20, 21, 22, 23, 24)), perm: 6778800, det: 0
</pre>

--------------------
Miller-Rabin_primality_test
--------------------

=={{header|FunL}}==
Direct implementation of the task algorithm.

<lang funl>import util.rnd

def isProbablyPrimeMillerRabin( n, k ) =
  n_1 = n - 1
  d = n_1
  s = 0

  while 2|d
    s++
    d /= 2

  for _ <- 1..k
    a = rnd( 2, n )
    x = a^d%n

    if x == 1 or x == n - 1 then continue

    for r <- 1..s - 1
      x = x^2%n

      if x == 1 then return false

      if x == n_1 then break
    else
      return false

  true

for i <- 3..100
  if isProbablyPrimeMillerRabin( i, 5 )
    println( i )</lang>

{{out}}

<pre>
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
</pre>

--------------------
Narcissistic_decimal_number
--------------------

=={{header|FunL}}==
<lang funl>def narcissistic( start ) =
  power = 1
  powers = array( 0..9 )

  def narc( n ) =
    num = n.toString()
    m = num.length()

    if power != m
      power = m
      powers( 0..9 ) = [i^m | i <- 0..9]

    if n == sum( powers(int(d)) | d <- num )
      n # narc( n + 1 )
    else
      narc( n + 1 )

  narc( start )

println( narcissistic(0).take(25) )</lang>

{{out}}

<pre>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315]
</pre>

--------------------
Pascal%27s_triangle
--------------------

=={{header|FunL}}==
=== Summing from Previous Rows ===
{{trans|Scala}}
<lang funl>import lists.zip

def
  pascal( 1 ) = [1]
  pascal( n ) = [1] + map( ((a, b)) -> a + b, zip(pascal(n-1), pascal(n-1).tail()) ) + [1]</lang>

=== Combinations ===
{{trans|Haskell}}
<lang funl>import integers.choose

def pascal( n ) = [choose( n - 1, k ) | k <- 0..n-1]</lang>

=== Pascal's Triangle ===
<lang funl>def triangle( height ) =
  width = max( map(a -> a.toString().length(), pascal(height)) )

  if 2|width
    width++

  for n <- 1..height
    print( ' '*((width + 1)\2)*(height - n) )
    println( map(a -> format('%' + width + 'd ', a), pascal(n)).mkString() )

triangle( 10 )</lang>

{{out}}
<pre>
                    1
                  1   1
                1   2   1
              1   3   3   1
            1   4   6   4   1
          1   5  10  10   5   1
        1   6  15  20  15   6   1
      1   7  21  35  35  21   7   1
    1   8  28  56  70  56  28   8   1
  1   9  36  84 126 126  84  36   9   1
</pre>

--------------------
Pi
--------------------

=={{header|FunL}}==
The code for <code>compute_pi()</code> is from [http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/spigot.pdf].  The number of digits may be given on the command line as an argument.  If there's no argument, the program will run until interrupted.

<lang funl>def compute_pi =
  def g( q, r, t, k, n, l ) =
    if 4*q + r - t < n*t
      n # g( 10*q, 10*(r - n*t), t, k, (10*(3*q + r))\t - 10*n, l )
    else
      g( q*k, (2*q + r)*l, t*l, k + 1, (q*(7*k + 2) + r*l)\(t*l), l + 2 )

  g( 1, 0, 1, 1, 3, 3 )

if _name_ == '-main-'
  print( compute_pi().head() + '.' )

  if args.isEmpty()
    for d <- compute_pi().tail()
      print( d )
  else
    for d <- compute_pi().tail().take( int(args(0)) )
      print( d )

    println()</lang>

--------------------
Power_set
--------------------

=={{header|FunL}}==
FunL uses Scala type <code>scala.collection.immutable.Set</code> as it's set type, which has a built-in method <code>subsets</code> returning an (Scala) iterator over subsets.

<lang funl>def powerset( s ) = s.subsets().toSet()</lang>

The powerset function could be implemented in FunL directly as:

<lang funl>def
  powerset( {} ) = {{}}
  powerset( s ) =
    acc = powerset( s.tail() )
    acc + map( x -> {s.head()} + x, acc )</lang>

or, alternatively as:

<lang funl>import lists.foldr

def powerset( s ) = foldr( (x, acc) -> acc + map( a -> {x} + a, acc), {{}}, s )

println( powerset({1, 2, 3, 4}) )</lang>

{{out}}

<pre>
ArraySeq(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</pre>

--------------------
Rot-13
--------------------

=={{header|FunL}}==
<lang funl>import io.{lines, stdin}

def rot13( s ) =
  buf = StringBuilder()

  for c <- s
    if isalpha( c )
      n = ((ord(c) and 0x1F) - 1 + 13)%26 + 1

      buf.append( chr(n or (if isupper(c) then 64 else 96)) )
    else
      buf.append( c )

  buf.toString()

def rot13lines( ls ) =
  for l <- ls
    println( rot13(l) )

if _name_ == '-main-'
  if args.isEmpty()
    rot13lines( stdin() )
  else
    for f <- args
      rot13lines( lines(f) )</lang>

--------------------
SHA-256
--------------------

=={{header|FunL}}==
A SHA-256 function can be defined using the Java support library.

<lang funl>native java.security.MessageDigest

def sha256Java( message ) = map( a -> format('%02x', a), list(MessageDigest.getInstance('SHA-256').digest(message.getBytes('UTF-8'))) ).mkString()</lang>

Here is a definition implemented as a direct translation of the pseudocode at '''[[wp:SHA-256|SHA-256]]'''.

<lang funl>def sha256( message ) =
  h0 = 0x6a09e667
  h1 = 0xbb67ae85
  h2 = 0x3c6ef372
  h3 = 0xa54ff53a
  h4 = 0x510e527f
  h5 = 0x9b05688c
  h6 = 0x1f83d9ab
  h7 = 0x5be0cd19

  k(0..63) = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]

  // preprocessing
  bits = BitArray( message.getBytes('UTF-8') )
  len = bits.length()
  bits.append( 1 )
  r = bits.length()%512
  bits.appendAll( 0 | _ <- 1..(if r > 448 then 512 - r + 448 else 448 - r) )
  bits.appendInt( 0 )
  bits.appendInt( len )

  words = bits.toIntVector()

  for chunk <- 0:words.length():16
    w(0..15) = words(chunk..chunk+15)

    for i <- 16..63
      s0 = (w(i-15) rotateright 7) xor (w(i-15) rotateright 18) xor (w(i-15) shiftright 3)
      s1 = (w(i-2) rotateright 17) xor (w(i-2) rotateright 19) xor (w(i-2) shiftright 10)
      w(i) = w(i-16) + s0 + w(i-7) + s1

    a = h0
    b = h1
    c = h2
    d = h3
    e = h4
    f = h5
    g = h6
    h = h7

    for i <- 0..63
      S1 = (e rotateright 6) xor (e rotateright 11) xor (e rotateright 25)
      ch = (e and f) xor ((not e) and g)
      temp1 = h + S1 + ch + k(i) + w(i)
      S0 = (a rotateright 2) xor (a rotateright 13) xor (a rotateright 22)
      maj = (a and b) xor (a and c) xor (b and c)
      temp2 = S0 + maj

      h = g
      g = f
      f = e
      e = d + temp1
      d = c
      c = b
      b = a
      a = temp1 + temp2

    h0 = h0 + a
    h1 = h1 + b
    h2 = h2 + c
    h3 = h3 + d
    h4 = h4 + e
    h5 = h5 + f
    h6 = h6 + g
    h7 = h7 + h

  map( a -> format('%08x', a.intValue()), [h0, h1, h2, h3, h4, h5, h6, h7] ).mkString()</lang>

Here is a test comparing the two and also verifying the hash values of the empty message string.

<lang funl>message = 'Rosetta code'

println( 'FunL: "' + message + '" ~> ' + sha256(message) )
println( 'Java: "' + message + '" ~> ' + sha256Java(message) )

message = ''

println( 'FunL: "' + message + '" ~> ' + sha256(message) )
println( 'Java: "' + message + '" ~> ' + sha256Java(message) )</lang>

{{out}}

<pre>
FunL: "Rosetta code" ~> 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
Java: "Rosetta code" ~> 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
FunL: "" ~> e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
Java: "" ~> e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</pre>

--------------------
Sorting_algorithms/Heapsort
--------------------

=={{header|FunL}}==
Direct translation of the pseudocode.  The array object (using Scala's <code>ArraySeq</code> class) has built-in method <code>length</code>, so the <code>count</code> parameter is not needed.

<lang funl>def heapSort( a ) =
  heapify( a )
  end = a.length() - 1

  while end > 0
    a(end), a(0) = a(0), a(end)
    siftDown( a, 0, --end )

def heapify( a ) =
  for i <- (a.length() - 2)\2..0 by -1
    siftDown( a, i, a.length() - 1 )

def siftDown( a, start, end ) =
  root = start

  while root*2 + 1 <= end
    child = root*2 + 1
    if child + 1 <= end and a(child) < a(child + 1)
      child++
    if a(root) < a(child)
      a(root), a(child) = a(child), a(root)
      root = child
    else
      break

a = array( [7, 2, 6, 1, 9, 5, 0, 3, 8, 4] )
heapSort( a )
println( a )</lang>

--------------------
Sorting_algorithms/Merge_sort
--------------------

=={{header|FunL}}==
<lang funl>import lists.splitAt

def
  sort( [] )          =  []
  sort( [x] )         =  [x]
  sort( xs )          =
    val (l, r) = splitAt( xs.length()\2, xs )
    merge( sort(l), sort(r) )

  merge( [], xs )     =  xs
  merge( xs, [] )     =  xs
  merge( x:xs, y:ys )
    | x <= y          =  x : merge( xs, y:ys )
    | otherwise       =  y : merge( x:xs, ys )</lang>

	--------------------
	Sorting_algorithms/Quicksort
	--------------------

	=={{header|FunL}}==
	<lang funl>def
		qsort( [] )    =  []
		qsort( p:xs )  =  qsort( filter((<p), xs) ) + [p] + qsort( filter((>=p), xs) )</lang>

Here is a more efficient version using the <code>partition</code> function.

<lang funl>import lists.partition

def
  qsort( [] )    =  []
  qsort( x:xs )  =
    val (ys, zs) = partition( (<x), xs )
    qsort( ys ) + (x : qsort( zs ))

println( qsort([4, 2, 1, 3, 0, 2]) )
println( qsort(["Bob", "Alice", "Barry", "Zoe", "Charlotte", "Fred"]) )</lang>

{{out}}

<pre>
[0, 1, 2, 2, 3, 4]
[Alice, Barry, Bob, Charlotte, Fred, Zoe]
</pre>
