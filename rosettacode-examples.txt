--------------------
100_doors
--------------------

=={{header|FunL}}==
=== Unoptimized ===
<lang funl>for i <- 1..100
  r = foldl1( (a, b) -> a xor b, [(a|i) | a <- 1..100] )
  println( i + ' ' + (if r then 'open' else 'closed') )</lang>

=== Optimized ===
<lang funl>import math.sqrt

for i <- 1..100
  println( i + ' ' + (if sqrt(i) is Integer then 'open' else 'closed') )</lang>

--------------------
99_Bottles_of_Beer
--------------------

=={{header|FunL}}==
<lang funl>val
  numbers = {1:'one', 2:'two', 3:'three', 4:'four', 5:'five', 6:'six', 7:'seven',
    8:'eight', 9:'nine', 10:'ten', 11:'eleven', 12:'twelve'}
  alt = {3:'thir', 5:'fif'}

def
  suffix( a, b ) = (if a.endsWith( 't' ) then a.substring( 0, a.length()-1 ) else a) + b

  number( n@(13 | 15) ) = suffix( alt(n%10), 'teen' )
  number( 20 ) = 'twenty'
  number( n@(30 | 50) ) = suffix( alt(n\10), 'ty' )
  number( n )
    | n <= 12 = numbers(n)
    | n <= 19 = suffix( numbers(n%10), 'teen' )
    | 10|n = suffix( numbers(n\10), 'ty' )
    | otherwise = number( n\10*10 ) + '-' + number( n%10 )

  cap( s ) = s.substring( 0, 1 ).toUpperCase() + s.substring( 1, s.length() )

  bottles( 0 ) = 'no more bottles'
  bottles( 1 ) = 'one bottle'
  bottles( n ) = number( n ) + ' bottles'

  verse( 0 )   = ('No more bottles of beer on the wall, no more bottles of beer.\n'
                  + 'Go to the store and buy some more, ninety-nine bottles of beer on the wall.')
  verse( n )   = (cap( bottles(n) ) + ' of beer on the wall, ' + bottles( n ) + ' of beer.\n'
                  + 'Take one down and pass it around, ' + bottles( n-1 )
                  + ' of beer on the wall.\n')

for i <- 99..0 by -1 do println( verse(i) )</lang>

--------------------
A%2BB
--------------------

=={{header|FunL}}==
<lang funl>println( sum(map(int, readLine().split(' +'))) )</lang>

--------------------
Ackermann_function
--------------------

=={{header|FunL}}==
<lang funl>def
  ackermann( 0, n ) = n + 1
  ackermann( m, 0 ) = ackermann( m - 1, 1 )
  ackermann( m, n ) = ackermann( m - 1, ackermann(m, n - 1) )

for m <- 0..3, n <- 0..4
  println( m, n, ackermann(m, n) )</lang>

--------------------
Bernoulli_numbers
--------------------

=={{header|FunL}}==
FunL has pre-defined function <code>B</code> in module <code>integers</code>, which is defined as:
<lang funl>import integers.choose

def B( n ) = sum( 1/(k + 1)*sum((if 2|r then 1 else -1)*choose(k, r)*(r^n) | r <- 0..k) | k <- 0..n )

for i <- 0..60 if i == 1 or 2|i
  printf( "B(%2d) = %s\n", i, B(i) )</lang>

{{out}}
<pre>
B( 0) = 1
B( 1) = -1/2
B( 2) = 1/6
B( 4) = -1/30
B( 6) = 1/42
B( 8) = -1/30
B(10) = 5/66
B(12) = -691/2730
B(14) = 7/6
B(16) = -3617/510
B(18) = 43867/798
B(20) = -174611/330
B(22) = 854513/138
B(24) = -236364091/2730
B(26) = 8553103/6
B(28) = -23749461029/870
B(30) = 8615841276005/14322
B(32) = -7709321041217/510
B(34) = 2577687858367/6
B(36) = -26315271553053477373/1919190
B(38) = 2929993913841559/6
B(40) = -261082718496449122051/13530
B(42) = 1520097643918070802691/1806
B(44) = -27833269579301024235023/690
B(46) = 596451111593912163277961/282
B(48) = -5609403368997817686249127547/46410
B(50) = 495057205241079648212477525/66
B(52) = -801165718135489957347924991853/1590
B(54) = 29149963634884862421418123812691/798
B(56) = -2479392929313226753685415739663229/870
B(58) = 84483613348880041862046775994036021/354
B(60) = -1215233140483755572040304994079820246041491/56786730
</pre>

--------------------
Command-line_arguments
--------------------

=={{header|FunL}}==
<lang funl>println( args )</lang>

--------------------
Dot_product
--------------------

=={{header|FunL}}==
<lang funl>import lists.zipWith

def dot( a, b )
  | a.length() == b.length() = sum( zipWith((x, y) -> x*y, a, b) )
  | otherwise = error( "Vector sizes must match" )

println( dot([1, 3, -5], [4, -2, -1]) )</lang>
{{out}}<pre>3</pre>

--------------------
Draw_a_clock
--------------------

=={{header|FunL}}==
<lang funl>import concurrent.{scheduleAtFixedRate, scheduler}

val ROW = 10
val COL = 20
val digits = array( [
  "   __",
  " /  /",
  "/__/ ",
  "     ",
  "    /",
  "   / ",
  "   __",
  "  __/",
  "/__  ",
  "   __",
  "  __/",
  " __/ ",
  "     ",
  " /__/",
  "   / ",
  "   __",
  " /__ ",
  " __/ ",
  "   __",
  " /__ ",
  "/__/ ",
  "   __",
  "    /",
  "   / ",
  "   __",
  " /__/",
  "/__/ ",
  "   __",
  " /__/",
  " __/ "
  ] )
val colon = array( [
  "  ",
  " .",
  ". "
  ] )

def displayTime =
  def pad( n ) = if n < 10 then '0' + n else n

  t = $time
  s = (t + $timeZoneOffset)\1000%86400
  time = pad( s\3600 ) + ':' + pad( s%3600\60 ) + ':' + pad( s%60 )

  for row <- 0:3
    print( if $os.startsWith('Windows') then '\n' else '\u001B[' + (ROW + row) + ';' + COL + 'H' )

    for ch <- time
      print( if ch == ':' then colon(row) else digits(int(ch)*3 + row) )

  println()
  t

if not $os.startsWith( 'Windows' )
  print( '\u001B[2J\u001B[?25l' )

scheduleAtFixedRate( displayTime, 1000 - displayTime()%1000, 1000 )
readLine()
scheduler().shutdown()

if not $os.startsWith( 'Windows' )
  print( '\u001B[?25h' )</lang>

{{out}}
<pre>
  __   __     __   __          __
  __/ /  / .  __/    / . /__/    /
/__  /__/ . /__     / .    /    /
</pre>

--------------------
Evaluate_binomial_coefficients
--------------------

=={{header|FunL}}==
FunL has pre-defined function <code>choose</code> in module <code>integers</code>, which is defined as:
<lang funl>def
  choose( n, k ) | k < 0 or k > n = 0
  choose( n, 0 ) = 1
  choose( n, n ) = 1
  choose( n, k ) = product( [(n - i)/(i + 1) | i <- 0:min( k, n - k )] )

println( choose(5, 3) )
println( choose(60, 30) )</lang>
{{out}}
<pre>
10
118264581564861424
</pre>

Here it is defined using the recommended formula for this task.
<lang funl>import integers.factorial

def
  binomial( n, k ) | k < 0 or k > n = 0
  binomial( n, k ) = factorial( n )/factorial( n - k )/factorial( k )</lang>

--------------------
Factorial
--------------------

=={{header|FunL}}==
=== Procedural ===
<lang funl>def factorial( n ) =
  if n < 0
    error( "factorial: n should be non-negative" )
  else
    res = 1

    for i <- 1..n
      res *= i

    res</lang>

=== Recursive ===
<lang funl>def
  factorial( (0|1) ) = 1
  factorial( n )
    | n > 0 = n*factorial( n - 1 )
    | otherwise = error( "factorial: n should be non-negative" )</lang>

=== Tail-recursive ===
<lang funl>def factorial( n )
  | n >= 0 =
    def
      fact( acc, 0 ) = acc
      fact( acc, n ) = fact( acc*n, n - 1 )

    fact( 1, n )
  | otherwise = error( "factorial: n should be non-negative" )</lang>

=== Using a library function (which uses folding) ===
<lang funl>def factorial( n )
  | n >= 0 = product( 1..n )
  | otherwise = error( "factorial: n should be non-negative" )</lang>

--------------------
Fibonacci_sequence
--------------------

=={{header|FunL}}==
=== Recursive ===
<lang funl>def
  fib( 0 ) = 0
  fib( 1 ) = 1
  fib( n ) = fib( n - 1 ) + fib( n - 2 )</lang>

=== Tail Recursive ===
<lang funl>def fib( n ) =
  def
    _fib( 0, prev, _ )    = prev
    _fib( 1, _,    next ) = next
    _fib( n, prev, next ) = _fib( n - 1, next, next + prev )

  _fib( n, 0, 1 )</lang>

=== Lazy List ===
<lang funl>val fib =
  def _fib( a, b ) = a # _fib( b, a + b )

  _fib( 0, 1 )

println( fib(10000) )</lang>

{{out}}

<pre>
3364476487643178326662161200510754331030214846068006390656476997468008144216666236815559551363373402558206533268083615937373479048386526826304089246305643188735454436955982749160660209988418393386465273130008883026923567361313511757929743785441375213052050434770160226475831890652789085515436615958298727968298751063120057542878345321551510387081829896979161312785626503319548714021428753269818796204693609787990035096230229102636813149319527563022783762844154036058440257211433496118002309120828704608892396232883546150577658327125254609359112820392528539343462090424524892940390170623388899108584106518317336043747073790855263176432573399371287193758774689747992630583706574283016163740896917842637862421283525811282051637029808933209990570792006436742620238978311147005407499845925036063356093388383192338678305613643535189213327973290813373264265263398976392272340788292817795358057099369104917547080893184105614632233821746563732124822638309210329770164805472624384237486241145309381220656491403275108664339451751216152
6545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562
430701794976171121233066073310059947366875
</pre>

=== Iterative ===
<lang funl>def fib( n ) =
  a, b = 0, 1

  for i <- 1..n
    a, b = b, a+b

  a</lang>

=== Binet's Formula ===
<lang funl>import math.sqrt

def fib( n ) =
  phi = (1 + sqrt( 5 ))/2
  int( (phi^n - (-phi)^-n)/sqrt(5) + .5 )</lang>

=== Matrix Exponentiation ===
<lang funl>def mul( a, b ) =
  res = array( a.length(), b(0).length() )

  for i <- 0:a.length(), j <- 0:b(0).length()
    res( i, j ) = sum( a(i, k)*b(k, j) | k <- 0:b.length() )

  vector( res )

def
  pow( _, 0 ) = vector( [[1, 0], [0, 1]] )
  pow( x, 1 ) = x
  pow( x, n )
    | 2|n = pow( mul(x, x), n\2 )
    | otherwise = mul(x, pow( mul(x, x), (n - 1)\2 ) )

def fib( n ) = pow( vector( [[0, 1], [1, 1]] ), n )(0, 1)

for i <- 0..10
  println( fib(i) )</lang>

{{out}}

<pre>
0
1
1
2
3
5
8
13
21
34
55
</pre>

--------------------
Greatest_element_of_a_list
--------------------

=={{header|FunL}}==
Using the pre-defined function <code>max</code>:
<lang funl>println( max([1,2,3,-1,0]) )</lang>
{{out}}
<pre>
3
</pre>

It can be implemented as:
<lang funl>def
  maximum( xs ) =
    def
      max( a, b )             = if a <= b then b else a

      foldl( f, z, [] )       = z
      foldl( f, z, x:xs )     = foldl( f, f(z, x), xs )

      foldl1( f, x:xs )       = foldl( f, x, xs )
      foldl1( _, [] )         = error( "foldl1: empty list" )

    foldl1( max, xs )</lang>

--------------------
Hailstone_sequence
--------------------

=={{header|FunL}}==
<lang funl>def
  hailstone( 1 ) = [1]
  hailstone( n ) = n # hailstone( if 2|n then n/2 else n*3 + 1 )

if _name_ == '-main-'
  h27 = hailstone( 27 )
  assert( h27.length() == 112 and h27.startsWith([27, 82, 41, 124]) and h27.endsWith([8, 4, 2, 1]) )

  val (n, len) = maxBy( snd, (i, hailstone( i ).length()) | i <- 1:100000 )

  println( n, len )</lang>

{{out}}

<pre>
77031, 351
</pre>

--------------------
Hello_world/Graphical
--------------------

=={{header|FunL}}==
<lang funl>native javax.swing.{SwingUtilities, JPanel, JLabel, JFrame}
native java.awt.Font

def createAndShowGUI( msg ) =
  f = JFrame()
  f.setTitle( msg )
  f.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE )
  p = JPanel()
  l = JLabel( msg )
  l.setFont( Font.decode(Font.SERIF + ' 150') )
  p.add( l )
  f.add( p )
  f.pack()
  f.setResizable( false )
  f.setVisible( true )

SwingUtilities.invokeLater( createAndShowGUI.runnable('Goodbye, World!') )</lang>

--------------------
Hello_world/Web_server
--------------------

=={{header|FunL}}==
<lang funl>native java.io.PrintWriter
native java.net.ServerSocket

val port = 8080
val listener = ServerSocket( port )

printf( 'Listening at port %1$d\n', port )

forever
  socket = listener.accept()
  PrintWriter( socket.getOutputStream(), true ).println( 'hello world' )
  socket.shutdownOutput()
  socket.close()</lang>
